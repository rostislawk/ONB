/*!
*******************************************************************************
\file mem.h
\brief Управление памятью
*//****************************************************************************
\author (С) Сергей Агиевич, http://apmi.bsu.by
\created 2012.07.16
\version 2014.10.21
*******************************************************************************
*/

#ifndef __MEM_H
#define __MEM_H

#include "defs.h"
#include <memory.h>
#include <string.h>
#include <malloc.h>

#ifdef __cplusplus
extern "C" {
#endif

/*!
*******************************************************************************
\file mem.h

Реализованы или переопределены манипуляции над буферами памяти, которые
интерпретируются как строки октетов.

Буфер памяти может представлять слова uint16, uint32, word.
Стандартными считаются соглашения LITTLE_ENDIAN (см. defs.h). Поэтому
на платформах с соглашениями BIG_ENDIAN при загрузке слова из памяти
и, наоборот, при сохранении слова в памяти выполняется реверс октетов
слова (см. макросы memRevXX).

Буфер памяти может представляться шестадцатеричной строкой. При этом
каждому октету буфера соответствуют два символа из множества
{'0',..,'9','A',...,'F','a',...,'f'}. Cимвол '\0' является признаком конца
строки.

Функции memToXXX и memFromXXX выполняют преобразования между буферами
памяти и другими структурами данных. Могут быть функции двух типов:
простые и сложные. В простых функциях объем памяти для размещения
преобразованных данных сразу известен. В простые функции передается
корректный указатель на буфер-назначение, простые функции не возвращают
никаких значений. В сложных функциях объем выходных данных рассчитывается
по входным и возвращается как выходное значение. В сложную функцию можно
передать нулевой указатель на буфер-назначение, получить требуемый объем
буфера, зарезервировать буфер и обратиться к функции еще один раз.

\pre В функции передаются корректные буферы памяти.

todo: safe = {memCmp, memCmpRev, memIsZero, memNonZeroSize?, memIsRep?,
	memCmpHex, memCmpHexRev}
*******************************************************************************
*/

/*
*******************************************************************************
Псевдонимы стандартных функций
*******************************************************************************
*/

/*!	Октеты буфера [count]src переписываются в буфер [count]dest.
	\pre Буферы src и dest не пересекаются.
*/
#define memCopy(dest, src, count) memcpy(dest, src, count)

/*!	Октеты буфера [count]src переписываются в буфер [count]dest.
	\remark Буферы src и dest могут пересекаться.
*/
#define memMove(dest, src, count) memmove(dest, src, count)

/*!	Буфер [count]buf заполняется октетом c. */
#define memSet(buf, c, count) memset(buf, c, count)

/*!	Буфер [count]buf обнуляется. */
#define memSetZero(buf, count) memSet(buf, 0, count)

/*!	Буферы [count]buf1 и [count]buf2 сравниваются лексикографически,
	\remark Октеты буферов сравниваются последовательно, от первого 
	к последнему. Первое несовпадение задает соотношение между 
	буферами.
*/
#define memCmp(buf1, buf2, count) memcmp(buf1, buf2, count)

/*!	Выделяется size октетов динамической памяти. */
#define memAlloc(size) malloc(size)

/*!	Размер блока динамической памяти memblock устанавливается равным size. */
#define memRealloc(memblock, size) realloc(memblock, size)

/*!	Освобождается блок динамической памяти memblock. */
#define memFree(memblock) free(memblock)

/*
*******************************************************************************
Дополнительные функции
*******************************************************************************
*/

/*!	\brief Корректный буфер памяти?

	Проверяется, что [count]buf является корректным буфером.
	\return Проверяемый признак.
	\remark Нулевой указатель buf является корректным, если count == 0.
*/
bool_t memIsValid(
	const void* buf,	/*!< [in] буфер */
	size_t count		/*!< [in] размер буфера */
);

/*!	\def memIsNullOrValid
	\brief Нулевой указатель или корректный буфер памяти? 
*/
#define memIsNullOrValid(buf, count)\
	((buf) == 0 || memIsValid(buf, count))

/*!	\brief Проверка совпадения

	Проверяется, что содержимое буферов [count]buf1 и [count]buf2 совпадает. 
	\return Признак совпадения.
	\safe Время выполнения функции зависит от заполнения буферов. 
	Имеется регулярная версия memEqSafe().
*/
bool_t memEq(
	const void* buf1,	/*!< [in] первый буфер */
	const void* buf2,	/*!< [in] второй буфер */
	size_t count		/*!< [in] размер буферов */
);

bool_t memEqSafe(const void* buf1, const void* buf2, size_t count);

/*!	\brief Обратное лексикографическое сравнение

	Буферы [count]buf1 и [count]buf2 сравниваются с использованием обратного 
	лексикографического порядка.
	\return 0, если буферы совпадают, положительное значение, если buf1 > buf2,
	и отрицательное значение, если buf1 < buf2.
	\remark Октеты буферов сравниваются последовательно, от последнего 
	к первому. Первое несовпадение задает соотношение между буферами.
*/
int memCmpRev(
	const void* buf1,	/*!< [in] первый буфер */
	const void* buf2,	/*!< [in] второй буфер */
	size_t count		/*!< [in] размер буферов */
);

/*!	\brief Очистить буфер памяти

	Буфер [count]buf очищается -- в него записываются произвольные октеты.
	\remark Запись выполняется всегда, даже если buf в дальнейшем не
	используется и включена оптимизация компиляции.
*/
void memWipe(
	void* buf,	        /*!< [out] буфер */
	size_t count		/*!< [in] размер буфера */
);

/*!	\brief Нулевой буфер памяти?

	Проверяется, что буфер [count]buf является нулевым.
	\return Проверяемый признак.
*/
bool_t memIsZero(
	const void* buf,	/*!< [out] буфер */
	size_t count		/*!< [in] размер буфера */
);

/*!	\brief Размер значащей части буфера

	Определяется размер значащей части буфера [count]buf.
	Незначащими считаются последние нулевые октеты буфера вплоть до первого
	ненулевого.
	\return Размер значащей части в октетах.
*/
size_t memNonZeroSize(
	const void* buf,	/*!< [out] буфер */
	size_t count		/*!< [in] размер буфера */
);

/*!	\brief Повтор октета?

	Проверяется, что [count]buf заполнен октетом o.
	\remark Считается, что в пустом буфере (count == 0) повторяется значение 0.
	\return Признак успеха.
*/
bool_t memIsRep(
	const void* buf,	/*!< [in] буфер */
	size_t count,		/*!< [in] размер буфера */
	octet o				/*!< [in] значение */
);

/*!	\brief Объединение двух буферов

	В буфер dest записывается сначала count1 октетов src1, а затем 
	count2 октетов src2.
	\pre По адресам src1, src2, dest зарезервировано count1, count2 и
	count1 +  count2 октетов памяти соответственно.
	\remark Буферы src1, src2 и dest могут пересекаться.
*/
void memJoin(
	void* dest,			/*!< [out] назначение */
	const void* src1,	/*!< [in] первый источник */
	size_t count1,		/*!< [in] число октетов src1 */
	const void* src2,	/*!< [in] второй источник */
	size_t count2		/*!< [in] число октетов src2 */
);

/*!	\brief Буферы одинакового размера не пересекаются?

	Проверяется, что буфер [count]buf1 не пересекается с буфером [count]buf2.
	\return Проверяемый признак.
	\pre Буферы buf1 и buf2 корректны.
*/
bool_t memIsDisjoint(
	const void* buf1,	/*!< [out] первый буфер */
	const void* buf2,	/*!< [out] второй буфер */
	size_t count		/*!< [in] размер буферов */
);

/*!	\brief Буферы совпадают или не пересекаются?

	Проверяется, что буфер [count]buf1 совпадает или не пересекается с буфером 
	[count]buf2.
	\return Проверяемый признак.
	\pre Буферы buf1 и buf2 корректны.
*/
bool_t memIsSameOrDisjoint(
	const void* buf1,	/*!< [out] первый буфер */
	const void* buf2,	/*!< [out] второй буфер */
	size_t count		/*!< [in] размер буферов */
);

/*!	\brief Два буфера не пересекаются?

	Проверяется, что буфер [count1]buf1 не пересекается с буфером [count2]buf2.
	\return Проверяемый признак.
	\pre Буферы buf1 и buf2 корректны.
*/
bool_t memIsDisjoint2(
	const void* buf1,	/*!< [out] первый буфер */
	size_t count1,		/*!< [in] размер buf1 */
	const void* buf2,	/*!< [out] второй буфер */
	size_t count2		/*!< [in] размер buf2 */
);

/*!	\brief Три буфера не пересекаются?

	Проверяется, что буферы [count1]buf1, [count2]buf2 и [count3]buf3 
	попарно не пересекаются.
	\return Проверяемый признак.
	\pre Буферы buf1, buf2 и buf3 корректны.
*/
bool_t memIsDisjoint3(
	const void* buf1,	/*!< [out] первый буфер */
	size_t count1,		/*!< [in] размер buf1 */
	const void* buf2,	/*!< [out] второй буфер */
	size_t count2,		/*!< [in] размер buf2 */
	const void* buf3,	/*!< [out] третий буфер */
	size_t count3		/*!< [in] размер buf3 */
);

/*!	\brief Четыре буфера не пересекаются?

	Проверяется, что буферы [count1]buf1, [count2]buf2, [count3]buf3 
	и [count4]buf4 попарно не пересекаются.
	\return Проверяемый признак.
	\pre Буферы buf1, buf2, buf3 и buf4 корректны.
*/
bool_t memIsDisjoint4(
	const void* buf1,	/*!< [out] первый буфер */
	size_t count1,		/*!< [in] размер buf1 */
	const void* buf2,	/*!< [out] второй буфер */
	size_t count2,		/*!< [in] размер buf2 */
	const void* buf3,	/*!< [out] третий буфер */
	size_t count3,		/*!< [in] размер buf3 */
	const void* buf4,	/*!< [out] четвертый буфер */
	size_t count4		/*!< [in] размер buf4 */
);

/*!	\brief Cложение октетов памяти по модулю 2

	В буфер [count]dest записывается поразрядная по модулю 2 сумма октетов
	октетов буферов [count]src1 и [count]src2.
	\pre Буфер dest либо не пересекается, либо совпадает с каждым из
	буферов src1, src2.
*/
void memXor(
	void* dest,			/*!< [out] сумма */
	const void* src1,	/*!< [in] первое слагаемое */
	const void* src2,	/*!< [in] второе слагаемое */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Добавление октетов памяти по модулю 2

	К октетам буфера [count]dest добавляются октеты буфера [count]src. 
	Сложение выполняется поразрядно по модулю 2.
	\pre Буфер dest либо не пересекается, либо совпадает с буфером src.
*/
void memXor2(
	void* dest,			/*!< [in/out] второе слагаемое / сумма */
	const void* src,	/*!< [in] первое слагаемое */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Перестановка октетов памяти

	Октеты буферов [count]buf1 и [count]buf2 меняются местами. 
	\pre Буферы buf1 и buf2 не пересекаются.
*/
void memSwap(
	void* buf1,		/*!< [in/out] первый буфер */
	void* buf2,		/*!< [in/out] второй буфер */
	size_t count	/*!< [in] число октетов */
);

/*!	\brief Сравнение с шестнадцатеричной строкой

	Буфер [strLen(hex) / 2]buf сравнивается с буфером, заданым 
	шестнадцатеричной строкой hex. Первая пара символов hex преобразуется 
	в октет, который сравнивается с первым октетом buf, вторая пара 
	сравнивается со вторым октетом buf и т.д.
	\pre Строка hex состоит из четного числа символов '0' -- '9', 'A' -- 'F'
	и признака конца строки '\0'.
	\return 1, если buf > hex, или -1, если buf < hex, или 0, если buf == hex.
	\remark Сравнение задается следующим псевдокодом:
	\code
		octet tmp[strLen(hex) / 2];
		memFromHex(tmp, hex);
		return memCmp(buf, tmp, strLen(hex) / 2);
	\endcode
*/
int memCmpHex(
	const void* buf,	/*!< [in] буфер */
	const char* hex		/*!< [in] шестнадцатеричная строка */
);

/*!	\brief Сравнение с обратной шестнадцатеричной строкой

	Буфер [strLen(hex) / 2]buf сравнивается с буфером, заданым 
	шестнадцатеричной строкой hex. Первая пара символов hex преобразуется 
	в октет, который сравнивается с последним октетом buf, вторая пара 
	сравнивается с предпоследним октетом buf и т.д.
	\pre Строка hex состоит из четного числа символов '0' -- '9', 'A' -- 'F'
	и признака конца строки '\0'.
	\return 1, если buf > hex, или -1, если buf < hex, или 0, если buf == hex.
	\remark Сравнение задается следующим псевдокодом:
	\code
		octet tmp[strLen(hex) / 2];
		memFromHex(tmp, hex);
		memRev(tmp, strLen(hex) / 2);
		return memCmp(buf, tmp, strLen(hex) / 2);
	\endcode
*/
int memCmpHexRev(
	const void* buf,	/*!< [in] буфер */
	const char* hex		/*!< [in] шестнадцатеричная строка */
);

/*
*******************************************************************************
Реверс октетов
*******************************************************************************
*/

/*!	\brief Реверс октетов

	Октеты буфера [count]buf записываются в обратном порядке.
*/
void memRev(
	void* buf,		/*!< [out] буфер */
	size_t count	/*!< [in] размер буфера */
);

/*!	\def memRevU16
	\brief Реверс октетов слова uint16
*/
#define memRevU16(a)\
	((a) << 8 | (a) >> 8)

/*!	\def memRevU32
	\brief Реверс октетов слова uint32
*/
#define memRevU32(a)\
	((a) << 24 | ((a) & 0xFF00) << 8 | ((a) >> 8 & 0xFF00) | (a) >> 24)

/*!	\def memRevU64
	\brief Реверс октетов слова uint64
	\pre Тип uint64 поддержан.
*/
#define memRevU64(a)\
	((a) << 56 | ((a) & 0xFF00) << 40 | ((a) & 0xFF0000) << 24 |\
	((a) & 0xFF000000) << 8 | ((a) >> 8 & 0xFF000000) |\
	((a) >> 24 & 0xFF0000) | ((a) >> 40 & 0xFF00) | (a) >> 56)

/*!	\def memRevWord
	\brief Реверс октетов машинного слова
*/
#if (B_PER_W == 16)
	#define memRevWord(a) memRevU16(a)
#elif (B_PER_W == 32)
	#define memRevWord(a) memRevU32(a)
#elif (B_PER_W == 64)
	#define memRevWord(a) memRevU64(a)
#else
	#error "Word size undefined"
#endif /* B_PER_W */

/*
*******************************************************************************
Преобразования
*******************************************************************************
*/

/*!	\brief Выгрузка в массив слов uint16

	Буфер [count]src преобразуется в массив [(count + 1) / 2]dest слов uint16.
*/
void memToU16(
	uint16 dest[],		/*!< [out] приемник */
	const void* src,	/*!< [in] источник */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Загрузка из массива слов uint16

	Буфер [count]dest формируется по массиву [(count + 1) / 2]src слов uint16.
*/
void memFromU16(
	void* dest,			/*!< [out] приемник */
	size_t count,		/*!< [in] число октетов */
	const uint16 src[]	/*!< [in] источник */
);

/*!	\brief Выгрузка в массив слов uint32

	Буфер [count]src преобразуется в массив [(count + 3) / 4]dest слов uint32.
*/
void memToU32(
	uint32 dest[],		/*!< [out] приемник */
	const void* src,	/*!< [in] источник */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Загрузка из массива слов uint32

	Буфер [count]dest формируется по массиву [(count + 3) / 4]src слов uint32.
*/
void memFromU32(
	void* dest,			/*!< [out] приемник */
	size_t count,		/*!< [in] число октетов */
	const uint32 src[]	/*!< [in] источник */
);

/*!	\brief Выгрузка в массив машинных слов

	Буфер [count]src преобразуется в массив [W_OF_O(count)]dest машинных слов.
*/
void memToWord(
	word dest[],		/*!< [out] приемник */
	const void* src,	/*!< [in] источник */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Загрузка из массива машинных слов

	Буфер [count]dest формируется по массиву [W_OF_O(count)]dest машинных слов.
*/
void memFromWord(
	void* dest,			/*!< [out] приемник */
	size_t count,		/*!< [in] число октетов */
	const word src[]	/*!< [in] источник */
);

/*!	\brief Выгрузка в шестнадцатеричную строку

	Буфер [count]src преобразуется в шестнадцатеричную строку dest. Первому 
	октету src соответствует первая пара символов dest, второму октету --
	вторая пара и т.д.
	\pre По адресу dest зарезервировано 2 * count + 1 символов.
	\pre Буферы dest и src не пересекаются.
*/
void memToHex(
	char* dest,			/*!< [out] строка-приемник */
	const void* src,	/*!< [in] память-источник */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Выгрузить в обратную шестнадцатеричную строку

	Буфер [count]src преобразуется в шестнадцатеричную строку dest. Первому 
	октету src соответствует последняя пара символов dest, второму октету --
	предпоследняя пара и т.д.
	\pre По адресу dest зарезервировано 2 * count + 1 символов.
	\pre Буферы dest и src не пересекаются.
*/
void memToHexRev(
	char* dest,			/*!< [out] строка-приемник */
	const void* src,	/*!< [in] память-источник */
	size_t count		/*!< [in] число октетов */
);

/*!	\brief Загрузка из шестнадцатеричной строки

	Шестнадцатеричная строка src преобразуется в строку октетов 
	[strLen(src) / 2]dest. По первой паре символов src определяется первый 
	октет dest, по второй паре -- второй октет и т.д.
	\pre Строка src состоит из четного числа символов '0' -- '9', 'A' -- 'F',
	'a' -- 'f' и признака конца строки '\0'.
*/
void memFromHex(
	void* dest,			/*!< [out] память-приемник */
	const char* src		/*!< [in] строка-источник */
);

/*!	\brief Загрузка из обратной шестнадцатеричной строки

	Шестнадцатеричная строка src преобразуется в строку октетов 
	[strLen(src) / 2]dest. По последней паре символов src определяется первый 
	октет dest, по предпоследней паре -- второй октет и т. д.
	\pre Строка src состоит из четного числа символов '0' -- '9', 'A' -- 'F',
	'a' -- 'f' и признака конца строки '\0'.
*/
void memFromHexRev(
	void* dest,			/*!< [out] память-приемник */
	const char* src		/*!< [in] строка-источник */
);

#ifdef __cplusplus
} /* extern "C" */
#endif

#endif /* __MEM_H */
